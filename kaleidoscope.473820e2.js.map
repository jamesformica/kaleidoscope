{"version":3,"sources":["index.js"],"names":["POINTS","RADIUS","SLICE","SLICE_HEIGHT","Math","abs","sin","PI","kCanvas","document","getElementById","kCtx","getContext","patternCanvas","patternCtx","width","height","invPatternCanvas","invPatternCtx","clearCanvas","canvas","ctx","clearRect","clearCanvases","drawWedge","degree","d2","save","beginPath","moveTo","arc","lineTo","clip","drawImage","img","x","y","restore","drawInverseWedge","translate","scale","drawWheel","i","rotate","random","min","max","floor","selectPoints","imgWidth","imgHeight","top","right","bottom","points","push","nextPoint","current","destination","pointCounter","createElement","onload","destinationPoint","window","requestAnimationFrame","loop","distanceX","distanceY","console","log","src","guitars"],"mappings":";;;AAmIA,aAnIA,IAAA,EAAA,EAAA,QAAA,sBAmIA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAjIA,IAAMA,EAAS,GACTC,EAAS,IACTC,EAAQ,GACRC,EAAeC,KAAKC,IAAID,KAAKE,IAAI,GAAKF,KAAKG,GAAK,KAAON,GAAU,GAEjEO,EAAUC,SAASC,eAAe,gBAClCC,EAAOH,EAAQI,WAAW,MAE1BC,EAAgBJ,SAASC,eAAe,WACxCI,EAAaD,EAAcD,WAAW,MAC5CC,EAAcE,MAAQd,EACtBY,EAAcG,OAASb,EAEvB,IAAMc,EAAmBR,SAASC,eAAe,cAC3CQ,EAAgBD,EAAiBL,WAAW,MAClDK,EAAiBF,MAAQd,EACzBgB,EAAiBD,OAASb,EAE1B,IAAMgB,EAAc,SAACC,EAAQC,GAC3BA,EAAIC,UAAU,EAAG,EAAGF,EAAOL,MAAOK,EAAOJ,SAGrCO,EAAgB,WACpBJ,EAAYN,EAAeC,GAC3BK,EAAYF,EAAkBC,GAC9BC,EAAYX,EAASG,IAGjBa,EAAY,WACZC,IAEEC,EAFO,IAEOxB,EAAQ,GAE5BY,EAAWa,OAGXb,EAAWc,YACXd,EAAWe,OAAO,EAAG1B,EAAe,GACpCW,EAAWgB,IAAI,EAAG3B,EAAe,EAAGF,GAAS,IAAMyB,GAAMtB,KAAKG,GAAK,IAAK,KAAaH,KAAKG,GAAK,KAC/FO,EAAWiB,OAAO,EAAG5B,EAAe,GAGpCW,EAAWkB,OACXlB,EAAWmB,UAAUC,EAAKC,EAAGC,EAAGnC,EAAQE,EAAc,EAAG,EAAGF,EAAQE,GACpEW,EAAWuB,WAGPC,EAAmB,WACvBpB,EAAcS,OACdT,EAAcqB,UAAU,EAAGpC,GAC3Be,EAAcsB,MAAM,GAAI,GACxBtB,EAAce,UAAUpB,EAAe,EAAG,GAC1CK,EAAcmB,WAGVI,EAAY,WAChB9B,EAAKgB,OACLhB,EAAK4B,UAAUtC,EAAQA,GAElB,IAAA,IAAIyC,EAAI,EAAGA,GAAK,IAAMxC,EAAOwC,GAAK,EACrC/B,EAAKgC,OAAOzC,EAAQE,KAAKG,GAAK,KAC9BI,EAAKsB,UAAUS,EAAI,EAAI7B,EAAgBI,EAAkB,EAAGd,GAAgB,GAG9EQ,EAAK0B,WAGDO,EAAS,SAACC,EAAKC,GAAQ1C,OAAAA,KAAK2C,MAAM3C,KAAKwC,UAAYE,EAAMD,GAAOA,IAEhEG,EAAe,SAACC,EAAUC,GAQzB,IAPCC,IAAAA,EAAMhD,EAENiD,EAAQH,EAAWhD,EACnBoD,EAASH,EAAY/C,EAErBmD,EAAS,GAENZ,EAAI,EAAGA,EAAI1C,EAAQ0C,GAAK,EAC/BY,EAAOC,KAAK,CAAEpB,EAAGS,EAPN,EAOmBQ,GAAQhB,EAAGQ,EAAOO,EAAKE,KAGhDC,OAAAA,GAGHE,EAAY,SAACC,EAASC,GACtBD,OAAAA,IAAYC,EAAoB,EAChCD,EAAUC,GAAqB,EAC5B,GAGLC,EAAe,EACfxB,GAAK,EACLC,GAAK,EAELF,EAAMzB,SAASmD,cAAc,OACjC1B,EAAI2B,OAAS,WACLP,IAAAA,EAASN,EAAad,EAAInB,MAAOmB,EAAIlB,QAE3CmB,EAAImB,EAAO,GAAGnB,EACdC,EAAIkB,EAAO,GAAGlB,EAEV0B,IAAAA,EAAmBR,EAAO,GA0B9BS,OAAOC,sBAxBM,SAAPC,IACJ1C,IACAC,IACAc,IACAG,IAEMyB,IAAAA,EAAY9D,KAAKC,IAAI8B,EAAI2B,EAAiB3B,GAC1CgC,EAAY/D,KAAKC,IAAI+B,EAAI0B,EAAiB1B,GAE9B,IAAd8B,GAAiC,IAAdC,GACrBC,QAAQC,IAAI,wBAEZP,EAAmBR,EADnBK,GAAgBA,EAAe,GAAK3D,IAE3BkE,IAAcC,GACvBhC,GAAKqB,EAAUrB,EAAG2B,EAAiB3B,GACnCC,GAAKoB,EAAUpB,EAAG0B,EAAiB1B,IAC1B8B,EAAYC,EACrBhC,GAAKqB,EAAUrB,EAAG2B,EAAiB3B,GAEnCC,GAAKoB,EAAUpB,EAAG0B,EAAiB1B,GAGrC2B,OAAOC,sBAAsBC,MAIjC/B,EAAIoC,IAAMC,EAAV","file":"kaleidoscope.473820e2.js","sourceRoot":"..","sourcesContent":["import guitars from './img/guitars.jpg'\n\nconst POINTS = 10\nconst RADIUS = 300\nconst SLICE = 30\nconst SLICE_HEIGHT = Math.abs(Math.sin(30 * Math.PI / 180) * RADIUS) + 10\n\nconst kCanvas = document.getElementById('kaleidoscope')\nconst kCtx = kCanvas.getContext('2d')\n\nconst patternCanvas = document.getElementById('pattern')\nconst patternCtx = patternCanvas.getContext('2d')\npatternCanvas.width = RADIUS\npatternCanvas.height = SLICE_HEIGHT\n\nconst invPatternCanvas = document.getElementById('invPattern')\nconst invPatternCtx = invPatternCanvas.getContext('2d')\ninvPatternCanvas.width = RADIUS\ninvPatternCanvas.height = SLICE_HEIGHT\n\nconst clearCanvas = (canvas, ctx) => {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nconst clearCanvases = () => {\n  clearCanvas(patternCanvas, patternCtx);\n  clearCanvas(invPatternCanvas, invPatternCtx);\n  clearCanvas(kCanvas, kCtx);\n}\n\nconst drawWedge = () => {\n  let degree = 345;\n  const d1 = degree - 0.5\n  const d2 = degree + SLICE + 0.2 // remove white seams\n\n  patternCtx.save()\n\n  // draw cheese wedge\n  patternCtx.beginPath();\n  patternCtx.moveTo(0, SLICE_HEIGHT / 2);\n  patternCtx.arc(0, SLICE_HEIGHT / 2, RADIUS, (360 - d2) * Math.PI / 180, (360 - d1) * Math.PI / 180);\n  patternCtx.lineTo(0, SLICE_HEIGHT / 2);\n\n  // crop image section into wedge\n  patternCtx.clip();\n  patternCtx.drawImage(img, x, y, RADIUS, SLICE_HEIGHT, 0, 0, RADIUS, SLICE_HEIGHT)\n  patternCtx.restore()\n}\n\nconst drawInverseWedge = () => {\n  invPatternCtx.save()\n  invPatternCtx.translate(0, SLICE_HEIGHT)\n  invPatternCtx.scale(1, -1);\n  invPatternCtx.drawImage(patternCanvas, 0, 0);\n  invPatternCtx.restore()\n}\n\nconst drawWheel = () => {\n  kCtx.save()\n  kCtx.translate(RADIUS, RADIUS)\n\n  for (let i = 0; i <= 360 / SLICE; i += 1) {\n    kCtx.rotate(SLICE * Math.PI / 180);\n    kCtx.drawImage(i % 2 ? patternCanvas : invPatternCanvas, 0, SLICE_HEIGHT / -2);\n  }\n\n  kCtx.restore()\n}\n\nconst random = (min, max) => Math.floor(Math.random() * (max - min) + min)\n\nconst selectPoints = (imgWidth, imgHeight) => {\n  const top = SLICE_HEIGHT\n  const left = 0\n  const right = imgWidth - RADIUS\n  const bottom = imgHeight - SLICE_HEIGHT\n\n  const points = []\n\n  for (let i = 0; i < POINTS; i += 1) {\n    points.push({ x: random(left, right), y: random(top, bottom) })\n  }\n\n  return points\n}\n\nconst nextPoint = (current, destination) => {\n  if (current === destination) return 0\n  if (current > destination) return -1\n  return 1\n}\n\nlet pointCounter = 1\nlet x = -1\nlet y = -1\n\nvar img = document.createElement('img');\nimg.onload = function () {\n  const points = selectPoints(img.width, img.height)\n\n  x = points[0].x\n  y = points[0].y\n\n  let destinationPoint = points[1]\n\n  const loop = () => {\n    clearCanvases()\n    drawWedge()\n    drawInverseWedge()\n    drawWheel()\n\n    const distanceX = Math.abs(x - destinationPoint.x)\n    const distanceY = Math.abs(y - destinationPoint.y)\n\n    if (distanceX === 0 && distanceY === 0) {\n      console.log('on to the next point')\n      pointCounter = (pointCounter + 1) % POINTS\n      destinationPoint = points[pointCounter]\n    } else if (distanceX === distanceY) {\n      x += nextPoint(x, destinationPoint.x)\n      y += nextPoint(y, destinationPoint.y)\n    } else if (distanceX > distanceY) {\n      x += nextPoint(x, destinationPoint.x)\n    } else {\n      y += nextPoint(y, destinationPoint.y)\n    }\n\n    window.requestAnimationFrame(loop)\n  }\n  window.requestAnimationFrame(loop)\n}\nimg.src = guitars;"]}